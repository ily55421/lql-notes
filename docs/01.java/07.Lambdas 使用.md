---
title: Lambdas 使用
name: link
date: 2022年8月16日15:15:28
---


# Lambdas 使用

## 避免长lambda表达式

```JAVA
package com.xpinjection.java8.misused.lambda;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;
import com.xpinjection.java8.misused.UserDto;

import java.util.List;
import java.util.function.Function;

import static java.util.stream.Collectors.toList;

/**
 * @author link
 * 避免长 Lambda表达式
 */
public class AvoidLongLambdas {
    /**
     * TODO ugly  长lambda表达式
     */
    @Ugly
    class LongLambdaInPlace {
        public List<UserDto> convertToDto(List<User> users){
            return users.stream()
                    .map(user -> {
                        UserDto dto = new UserDto();
                        dto.setId(user.getId());
                        dto.setName(user.getName());
                        // it happens to be much more fields and much more logic in terms of remapping these fields
                        // 就重新映射这些字段而言，它恰好是更多的字段和更多的逻辑
                        return dto;
                    })
                    .collect(toList());
        }
    }

    /**
     * TODO good 方法参考而不是 Lambda
     * 将复杂逻辑封装后才能函数方法
     */
    @Good
    class MethodReferenceInsteadOfLambda {
        //particular toDto could be implemented as a separate class or as a lambda function
        private final Function<User, UserDto> toDto = this::convertToDto;

        public List<UserDto> convertToDto(List<User> users){
            return users.stream()
                    // 封装转换方法
                    .map(toDto)
                    .collect(toList());
        }

        private UserDto convertToDto(User user){
            UserDto dto = new UserDto();
            dto.setId(user.getId());
            dto.setName(user.getName());
            return dto;
        }
    }
}

```

## 避免复杂的lambda表达式

```JAVA
package com.xpinjection.java8.misused.lambda;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Permission;
import com.xpinjection.java8.misused.Role;
import com.xpinjection.java8.misused.User;

import java.util.HashSet;
import java.util.Set;
import java.util.function.Predicate;

import static java.util.stream.Collectors.toSet;

/**
 *
 * @author link
 * TODO 避免复杂的 Lambda表达式
 */
public class AvoidComplexLambdas {
    private final Set<User> users = new HashSet<>();

    @Ugly
    class UsingComplexLambdaInPlace {
        public Set<User> findEditors() {
            return users.stream()
                    // 复杂的表达式过滤
                    .filter(u -> u.getRoles().stream()
                            .anyMatch(r -> r.getPermissions().contains(Permission.EDIT)))
                    .collect(toSet());
        }
    }

    @Good
    class ComplexityExtractedToMethodReference {
        public Set<User> checkPermission(Permission permission) {
            return users.stream()
                    // 可选
                    //.filter(this::hasEditPermission)
                    .filter(hasPermission(Permission.EDIT))
                    .collect(toSet());
        }

        private Predicate<User> hasPermission(Permission permission) {
            return user -> user.getRoles().stream()
                    .map(Role::getPermissions)
                    .anyMatch(permissions -> permissions.contains(permission));
        }

        /**
         * 是否有编辑权限
         * @param user
         * @return
         */
        private boolean hasEditPermission(User user) {
            // 根据给定参数评估此谓词。
            return hasPermission(Permission.EDIT).test(user);
        }
    }
}

```

## lambda类设计

```JAVA
package com.xpinjection.java8.misused.lambda;

import com.xpinjection.java8.misused.Annotations.Bad;
import com.xpinjection.java8.misused.Annotations.Good;

import java.util.function.Function;
import java.util.function.UnaryOperator;

/**
 * @author link
 * TODO 类设计
 */
public class ClassDesign {
    /**
     * TODO 模棱两可的重载方法
     * 函数式接口的重载 需要区分
     */
    @Bad
    static class AmbiguousOverloadedMethods {
        interface AmbiguousService<T> {
            <R> R process(Function<T, R> fn);

            T process(UnaryOperator<T> fn);
        }

        public void usage(AmbiguousService<String> service) {
            // which method you intended to call??? both are acceptable.
            // 你打算调用哪个方法？？？两者都可以接受。
            service.process(String::toUpperCase);
        }
    }

    /**
     * TODO good 单独的专门方法
     */
    @Good
    static class SeparateSpecializedMethods {
        interface ClearService<T> {
            <R> R convert(Function<T, R> fn);

            T process(UnaryOperator<T> fn);
        }

        public void usage(ClearService<String> service) {
            // now it's clear which method will be called.
            // 现在很清楚将调用哪个方法。
            service.convert(String::toUpperCase);
        }
    }
}

```

## Lambda 并不总是最好的选择

```JAVA
package com.xpinjection.java8.misused.lambda;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.Optional;

/**
 * @author link
 * TODO Lambda 并不总是最好的选择
 */
public class LambdasAreNotAlwaysTheBestOption {
    /**
     * TODO 不需要的 Lambda 用法
     */
    @Ugly
    class UnneededLambdasUsage {
        public void processAndPrint(String name) {
            Optional.ofNullable(name)
                    // 不需要的判空
                    //.filter(s -> !s.isEmpty())
                    .map(s -> s.toUpperCase())
                    // 流程拼接
                    .map(s -> doProcess(s))
                    .ifPresent(s -> System.out.print(s));
        }

        private String doProcess(String name) {
            return "MR. " + name;
        }
    }

    @Good
    class MethodReferenceUsage {
        public void processAndPrint(String name) {
            Optional.ofNullable(name)
                    // 替换为适当的库方法 ref 引用
                    //.filter(StringUtils::isNotEmpty) // replace with appropriate library method ref
                    .map(String::toUpperCase)
                    .map(this::doProcess)
                    .ifPresent(System.out::print);
        }

        private String doProcess(String name) {
            return "MR. " + name;
        }
    }
}

```

## 惰性计算提高性能

```JAVA
package com.xpinjection.java8.misused.lambda;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.Set;
import java.util.function.Supplier;

/**
 * @author link
 * TODO 惰性计算提高性能
 */
public class LazyCalculationsImprovePerformance {
    /**
     * TODO ugly 使用附加检查进行日志记录以避免计算
     */
    @Ugly
    static class LoggingWithAdditionalCheckToAvoidCalculations {
        private static final Log LOG = null; // init logger with factory

        /**
         * 向用户发送欢迎电子邮件
         * @param users
         */
        public void sendWelcomeEmailToUsers(Set<User> users) {
            // send email
            // 已启用调试
            if (LOG.isDebugEnabled()) {
                // 已为用户发送电子邮件
                LOG.debug("Emails have been sent for users: " + users);
            }
        }

        interface Log {
            void debug(String message);

            boolean isDebugEnabled();
        }
    }

    /**
     * TODO 将 Lambda 传递给延迟计算日志消息的值
     */
    @Good
    static class PassLambdaToLazyCalculateValueForLogMessage {
        private static final Log LOG = null; // init logger with factory

        public void sendWelcomeEmailToUsers(Set<User> users) {
            // send email
            LOG.debug(() -> "Emails have been sent for users: " + users);
        }

        interface Log {
            void debug(String message);

            boolean isDebugEnabled();

            /**
             * 默认方法调用 中进行判断
             * 使用supplier函数接口
             * @param message
             */
            default void debug(Supplier<String> message) {
                if (isDebugEnabled()) {
                    debug(message.get());
                }
            }
        }
    }
}
```

## 模拟多视图

```JAVA
package com.xpinjection.java8.misused.lambda.collections;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.*;

/**
 * @author link
 * 模拟多视图
 */
public class EmulateMultimap {
    private final Map<String, Set<User>> usersByRole = new HashMap<>();

    /**
     * TODO ugly 为键手动插入第一个值的集合
     */
    @Ugly
    class ManuallyInsertSetOnFirstValueForTheKey {
        public void addUser(User user) {
            user.getRoles().forEach(r -> {
                //
                Set<User> usersInRole = usersByRole.get(r.getName());
                // 为空则新增
                if (usersInRole == null) {
                    usersInRole = new HashSet<>();
                    usersByRole.put(r.getName(), usersInRole);
                }
                // 添加用户
                usersInRole.add(user);
            });
        }

        /**
         * 获取角色中的用户组
         * @param role
         * @return
         */
        public Set<User> getUsersInRole(String role) {
            Set<User> users = usersByRole.get(role);
            return users == null ? Collections.emptySet() : users;
        }
    }

    /**
     * TODO good 如果键不存在则计算空集
     */
    @Good
    class ComputeEmptySetIfKeyIsAbsent {
        public void addUser(User user) {
            user.getRoles()
                    .forEach(r ->
                            usersByRole
                                    // usersByRole.get(r.getName()) 如果不存在 则new一个新的set
                    .computeIfAbsent(r.getName(), k -> new HashSet<>())
                                    // 添加用户
                    .add(user)
                    );
        }

        public Set<User> getUsersInRole(String role) {
            // 获取或默认
            return usersByRole.getOrDefault(role, Collections.emptySet());
        }
    }
}
```

## list列表排序

```JAVA
package com.xpinjection.java8.misused.lambda.collections;

import com.xpinjection.java8.misused.User;
import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.List;

import static java.util.Comparator.comparing;

/**
 * @author link
 * TODO 列表排序
 */
public class ListSorting {
    /**
     * TODO ugly 使用自定义比较器
     */
    @Ugly
    class UsingCustomComparator {
        public void sortUsersById(List<User> users) {
            users.sort((x, y) -> Long.compare(x.getId(), y.getId()));
        }
    }

    /**
     * TODO good 使用现有的预定义比较器
     */
    @Good
    class UsingExistingPredefinedComparator {
        public void sortUsersById(List<User> users) {
            // comparing 预定义排序方法
            users.sort(comparing(User::getId));
        }
    }
}
```

## map迭代

```JAVA
package com.xpinjection.java8.misused.lambda.collections;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.HashMap;
import java.util.Map;

import static java.util.stream.Collectors.toMap;

/**
 * @author link
 * TODO map 迭代
 */
public class MapIterating {
    /**
     * TODO ugly 使用旧的良好的条目集
     */
    @Ugly
    class UsingOldGoodEntrySet {
        public Map<String, String> getUserNames(Map<String, User> users) {
            Map<String, String> userNames = new HashMap<>();
            // entrySet 条目集遍历
            users.entrySet().forEach(user ->
                    userNames.put(user.getKey(), user.getValue().getName()));
            return userNames;
        }
    }

    /**
     * TODO good 使用map直接遍历
     */
    @Good
    class UsingMapForEach {
        public Map<String, String> getUserNames(Map<String, User> users) {
            Map<String, String> userNames = new HashMap<>();
            // 获取用户名称
            users.forEach((key, value) -> userNames.put(key, value.getName()));
            return userNames;
        }
    }

    /**
     * 使用map 转换
     */
    @Good
    class UsingMapTransform {
        public Map<String, String> getUserNames(Map<String, User> users) {
            return users.entrySet().stream()
                    .collect(toMap(Map.Entry::getKey,
                            // 映射value
                            entry -> entry.getValue().getName()));
        }
    }
}
```

## 使用迭代器删除元素

```JAVA
package com.xpinjection.java8.misused.lambda.collections;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Permission;
import com.xpinjection.java8.misused.User;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

/**
 * @author link
 * TODO 使用迭代器删除元素
 */
public class RemoveElementWithIterator {
    private final Set<User> users = new HashSet<>();

    /**
     * TODO ugly 使用 Iterator Remove 手动删除元素
     */
    @Ugly
    class ManuallyRemoveElementWithIteratorRemove {
        /**
         * 删除有权限的用户
         * @param permission
         */
        public void removeUsersWithPermission(Permission permission) {
            // 获取集合的迭代器
            Iterator<User> iterator = users.iterator();
            while (iterator.hasNext()) {
                User user = iterator.next();
                // if中复杂的表达式
                if (user.getRoles().stream()
                        .anyMatch(r -> r.getPermissions().contains(permission))) {
                    iterator.remove();
                }
            }
        }
    }

    /**
     * TODO good 用Predicate接口判断 删除
     */
    @Good
    class RemoveWithPredicate {
        public void removeUsersWithPermission(Permission permission) {
            // 默认方法有实现迭代器删除逻辑
            // TODO 使用迭代器删除list所有包含过滤条件的角色
            users.removeIf(user -> user.getRoles().stream()
                    .anyMatch(r -> r.getPermissions().contains(permission)));
        }
    }
}
```

# Optional

## 内部可选用法

```JAVA
package com.xpinjection.java8.misused.optional.usage;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.Optional;

/**
 * @author link
 * 内部可选用法
 */
public class InternalOptionalUsage {
    /**
     * TODO ugly 使用空值检查不清楚可选依赖项
     */
    @Ugly
    class UnclearOptionalDependencyWithCheckForNull {
        private Printer printer;

        public void process(User user) {
            //some processing
            if (printer != null) {
                // 非空打印
                printer.print(user);
            }
        }

        public void setPrinter(Printer printer) {
            this.printer = printer;
        }
    }

    /**
     * TODO good 有效的内部可选依赖
     */
    @Good
    class ValidInternalOptionalDependency {
        /**
         * 空容器对象
         */
        private Optional<Printer> printer = Optional.empty();

        public void process(User user) {
            //some processing
            printer.ifPresent(p -> p.print(user));
        }

        public void setPrinter(Printer printer) {
            this.printer = Optional.ofNullable(printer);
        }
    }

    interface Printer {
        void print(User user);
    }
}
```

## 可选的构造函数参数

```JAVA
package com.xpinjection.java8.misused.optional.usage;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.io.Serializable;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

/**
 * TODO 可选的构造函数参数
 * @author link
 */
public class OptionalConstructorParameters {
    /**
     * 可选的 类外暴露
     */
    @Ugly
    class OptionalLeaksOutsideClass {
        /**
         * 邮件创建
         * @return
         */
        public List<Email> create() {
            Email noAttachment = new Email("First!", "No attachment", Optional.empty());
            Attachment attachment = new Attachment("/mnt/files/image.png", 370);
            Email withAttachment = new Email("Second!", "With attachment", Optional.of(attachment));
            return Arrays.asList(noAttachment, withAttachment);
        }

        class Email implements Serializable {
            private final String subject;
            private final String body;
            private final Optional<Attachment> attachment;

            Email(String subject, String body, Optional<Attachment> attachment) {
                this.subject = subject;
                this.body = body;
                this.attachment = attachment;
            }

            String getSubject() {
                return subject;
            }

            String getBody() {
                return body;
            }

            Optional<Attachment> getAttachment() {
                return attachment;
            }
        }
    }

    /**
     * TODO good 重载的构造函数
     */
    @Good
    class OverloadedConstructors {
        public List<Email> create() {
            Email noAttachment = new Email("First!", "No attachment");
            Attachment attachment = new Attachment("/mnt/files/image.png", 370);
            Email withAttachment = new Email("Second!", "With attachment", attachment);
            return Arrays.asList(noAttachment, withAttachment);
        }

        class Email implements Serializable {
            private final String subject;
            private final String body;
            private final Attachment attachment;

            Email(String subject, String body, Attachment attachment) {
                this.subject = subject;
                this.body = body;
                this.attachment = attachment;
            }

            /**
             * 重载构造
             * @param subject
             * @param body
             */
            Email(String subject, String body) {
                this(subject, body, null);
            }

            String getSubject() {
                return subject;
            }

            String getBody() {
                return body;
            }

            boolean hasAttachment() {
                return attachment != null;
            }

            Attachment getAttachment() {
                return attachment;
            }
        }
    }

    /**
     * 属性类
     */
    class Attachment {
        private final String path;
        private final int size;

        Attachment(String path, int size) {
            this.path = path;
            this.size = size;
        }

        String getPath() {
            return path;
        }

        int getSize() {
            return size;
        }
    }
}
```

## 可选的集合

```JAVA
package com.xpinjection.java8.misused.optional.usage;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

/**
 * @author link
 * TODO 可选的集合
 */
public class OptionalForCollections {
    private static final String ADMIN_ROLE = "admin";

    /**
     * 过于冗长
     */
    @Ugly
    class TooVerbose {
        public User findAnyAdmin() {
            Optional<List<User>> users = findUsersByRole(ADMIN_ROLE);
            if (users.isPresent() && !users.get().isEmpty()) {
                return users.get().get(0);
            }
            throw new IllegalStateException("No admins found");
        }

        private Optional<List<User>> findUsersByRole(String role) {
            //real search in DB
            return Optional.empty();
        }
    }

    /**
     * TODO good 干净整洁
     */
    @Good
    class NiceAndClean {
        public User findAnyAdmin() {
            return findUsersByRole(ADMIN_ROLE).stream()
                    .findAny()
                    .orElseThrow(() -> new IllegalStateException("No admins found"));
        }

        private List<User> findUsersByRole(String role) {
            // real search in DB  数据库中的真实搜索
            // 实际查询结果返回
            return Collections.emptyList();
        }
    }
}
```

## 百与一的方法

```JAVA
package com.xpinjection.java8.misused.optional;

import com.xpinjection.java8.misused.Annotations.Bad;
import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.Optional;

import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;

/**
 * 一百零一法
 * @author link
 */
public class HundredAndOneApproach {
    /**
     * TODO 相同的旧命令式风格
     */
    @Ugly
    class SameOldImperativeStyle {
        /**
         * 获取人车保险名称
         * @param person
         * @return
         */
        public String getPersonCarInsuranceName(Person person) {
            String name = "Unknown";
            if (ofNullable(person).isPresent()) {
                // 在场
                if (person.getCar().isPresent()) {
                    // car在场
                    if (person.getCar().get().getInsurance().isPresent()) {
                        // car的 insurance 在场
                        // 赋值保险名称
                        name = person.getCar().get().getInsurance().get().getName();
                    }
                }
            }
            return name;
        }
    }

    /**
     * TODO ugly 以与 Dirty Hack 相同的命令方式使用 If Present
     */
    @Ugly
    class UsingIfPresentInSameImperativeWayWithDirtyHack {
        public String getPersonCarInsuranceName(Person person) {
            final StringBuilder builder = new StringBuilder();
            // 人在场
            ofNullable(person).ifPresent(
                    // car 在场
                    p -> p.getCar().ifPresent(
                            // 保险在场
                            c -> c.getInsurance().ifPresent(
                                    // 拼接 builder
                                    i -> builder.append(i.getName())
                            )
                    )
            );
            return builder.toString();
        }
    }

    /**
     * TODO bad  使用未选中获取的map
     */
    @Bad
    class UsingMapWithUncheckedGet {
        public String getPersonCarInsuranceName(Person person) {
            // person 在场
            return ofNullable(person)
                    // 获取car
                    .map(Person::getCar)
                    // 获取 insurance
                    .map(car -> car.get().getInsurance())
                    // 获取 insurance的 name
                    .map(insurance -> insurance.get().getName())
                    // 否则返回 Unknown
                    .orElse("Unknown");
        }
    }

    /**
     * TODO ugly 使用带有或其他空对象的map来修复未选中的获取
     */
    @Ugly
    class UsingMapWithOrElseEmptyObjectToFixUncheckedGet {
        public String getPersonCarInsuranceName(Person person) {
            return ofNullable(person)
                    .map(Person::getCar)
                    // car.orElseGet(Car::new) 不存在获取一个空car 对象
                    .map(car -> car.orElseGet(Car::new).getInsurance())
                    // insurance.orElseGet(Insurance::new) 不存在获取一个空insurance 对象
                    .map(insurance -> insurance.orElseGet(Insurance::new).getName())
                    .orElse("Unknown");
        }
    }

    /**
     * TODO good 使用平铺map
     */
    @Good
    class UsingFlatMap {
        public String getCarInsuranceNameFromPersonUsingFlatMap(Person person) {
            return ofNullable(person)
                    // 获取car映射流
                    .flatMap(Person::getCar)
                    // 获取insurance映射流
                    .flatMap(Car::getInsurance)
                    // 获取保险名称
                    .map(Insurance::getName)
                    // 或者 Unknown（未知）
                    .orElse("Unknown");
        }
    }

    class Person {
        Optional<Car> getCar() {
            return empty(); //stub
        }
    }

    class Car {
        Optional<Insurance> getInsurance() {
            return empty(); //stub
        }
    }

    class Insurance {
        String getName() {
            return ""; //stub
        }
    }
}
```

## IF语句并不总是坏事

```JAVA
package com.xpinjection.java8.misused.optional;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.Optional;
import java.util.stream.Stream;

/**
 * TODO IF语句并不总是坏事
 * @author link
 */
public class IfStatementIsNotAlwaysBadThing {
    /**
     * TODO Ugly 以巧妙的方式组合一些选项
     * 连个容器数转int  reduce归约 求和
     */
    @Ugly
    class CombineSomeOptionalsInCleverWay {
        public Optional<Integer> sum(Optional<Integer> first, Optional<Integer> second) {
            return Stream.of(first, second)
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .reduce(Integer::sum);
        }
    }

    /**
     * TODO Ugly 以更聪明的方式玩地图游戏
     */
    @Ugly
    class PlayMapGameInEvenMoreCleverWay {
        public Optional<Integer> sum(Optional<Integer> first, Optional<Integer> second) {
            // b -> second.map(a -> b + a).orElse(b)  映射成相加的值否则返回自身
            return first.map(b -> second.map(a -> b + a).orElse(b))
                    .map(Optional::of)
                    // 返回具有指定当前非空值的Optional  如果a不为空即返回，否则返回 second
                    .orElse(second);
        }
    }

    /**
     * TODO good 老派但完全清晰的代码
     */
    @Good
    class OldSchoolButTotallyClearCode {
        public Optional<Integer> sum(Optional<Integer> first, Optional<Integer> second) {
            // 判空 一个不存在 直接返回null 的容器
            if (!first.isPresent() && !second.isPresent()) {
                return Optional.empty();
            }
            // first.orElse(0) + second.orElse(0) 存在则相加
            return Optional.of(first.orElse(0) + second.orElse(0));
        }
    }
}
```

## 可选optional

```JAVA
package com.xpinjection.java8.misused.optional;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import static java.util.Optional.ofNullable;

/**
 * @author link
 * TODO  可选
 */
public class OptionalElvis {
    /**
     * TODO ugly  java8之前
     */
    @Ugly
    class BeforeJava8 {
        public String getUserName(User user) {
            return (user != null && user.getName() != null) ? user.getName() : "default";
        }
    }

    /**
     * TODO 使用 Optional IsPresent
     * 多重嵌套
     */
    @Ugly
    class UsingOptionalIsPresent {
        public String getUserName(User user) {
            if (ofNullable(user).isPresent()) {
                if (ofNullable(user.getName()).isPresent()) {
                    return user.getName();
                }
            }
            return "default";
        }
    }

    /**
     * 使用 OrElse
     */
    @Good
    class UsingOrElse {
        String getUserName(User user) {
            // import static java.util.Optional.ofNullable; 静态方法导入
            return ofNullable(user)
                    .map(User::getName)
                    .orElse("default");
        }
    }
}
```

## 可选工程-简单的条件复制

```JAVA
package com.xpinjection.java8.misused.optional;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Role;

import java.util.Optional;

/**
 * @author link
 * TODO 可选工程
 */
public class OptionalOverEngineering {
    /**
     * TODO 工程上的空保护
     */
    @Ugly
    class NullProtectionOverEngineering {
        /**
         * 复制角色对象
         * @param role
         * @return
         */
        public Role copyRole(Role role) {
            Role copy = new Role();
            // 多余调用容器的判空
            Optional.ofNullable(role.getName())
                    .ifPresent(copy::setName);
            copy.setPermissions(role.getPermissions());
            return copy;
        }
    }

    /**
     * TODO 简单的条件复制
     */
    @Good
    class SimpleConditionalCopying {
        public Role copyRole(Role role) {
            Role copy = new Role();

            if (role.getName() != null) {
                copy.setName(role.getName());
            }
            copy.setPermissions(role.getPermissions());
            return copy;
        }
    }
}
```

## 严格检查值存在

```JAVA
package com.xpinjection.java8.misused.optional;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.Optional;

/**
 * @author link
 * TODO 严格检查价值存在
 */
public class StrictCheckOfValuePresence {
    /**
     * TODO 手动检查是否存在抛出异常
     */
    @Ugly
    class ManualCheckForPresenceToThrowException {
        /**
         * 获取用户名称
         * @param userId
         * @return
         */
        public String getUserName(Long userId) {
            Optional<User> user = findById(userId);
            if (user.isPresent()) {
                return user.get().getName();
            }
            // 抛出  非法状态异常
            throw new IllegalStateException("User not found");
        }

        /**
         * 根据用户id删除用户 （存在则删除）
         * @param userId
         */
        public void deleteUser(Long userId) {
            Optional<User> user = findById(userId);
            if (user.isPresent()) {
                delete(user.get());
            }
        }

        /**
         * 删除方法
         * @param user
         */
        private void delete(User user) {
            //delete from DB
        }
    }

    /**
     * TODO OrElse 的抛出用法
     */
    @Good
    class OrElseThrowUsage {
        public String getUserName(Long userId) {
            return findById(userId)
                    // orElseThrow 否则抛出异常
                    .orElseThrow(() -> new IllegalStateException("User not found"))
                    .getName();
        }

        /**
         * 方法引用调用删除
         * @param userId
         */
        public void deleteUser(Long userId) {
            findById(userId).ifPresent(this::delete);
        }

        private void delete(User user) {
            //delete from DB
        }
    }

    /**
     * 根据id查找一个用户
     * @param userId
     * @return
     */
    private Optional<User> findById(Long userId) {
        //search in DB
        return Optional.of(new User(5L, "Mikalai", 33));
    }
}
```

# Stream

## 避免流中的循环

```JAVA
package com.xpinjection.java8.misused.stream.collectors;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

/**
 *
 * @author link
 * TODO 避免流中的循环
 */
public class AvoidLoopsInStreams {
    private final Set<User> users = new HashSet<>();

    /**
     * TODO 使用外部计数器
     */
    @Ugly
    class UseExternalCounter {
        /**
         * count 每个用户的平均角色数
         * @return
         */
        public double countAverageRolesPerUser() {
            if (users.isEmpty()) {
                return 0;
            }
            AtomicInteger totalCount = new AtomicInteger();
            users.forEach(u -> totalCount.addAndGet(u.getRoles().size()));
            return totalCount.doubleValue() / users.size();
        }
    }

    /**
     * 应用映射到目标类型
     */
    @Good
    class ApplyMappingsToTargetType {
        public double countAverageRolesPerUser() {
            return users.stream()
                    // 转换成double流
                    .mapToDouble(u ->
                            // 获取每个用户的角色数
                            u.getRoles().size())
                    // 求平均
                    .average()
                    // 不存在则返回0
                    .orElse(0);
        }
    }
}
```

## 收集链式

```JAVA
package com.xpinjection.java8.misused.stream.collectors;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.List;
import java.util.Map;

import static java.util.Comparator.comparing;
import static java.util.stream.Collectors.*;

/**
 * @author link
 * TODO 收集链
 */
public class CollectorsChain {
    /**
     * TODO ugly 分组依据和转换结果map
     */
    @Ugly
    class GroupByAndTransformResultingMap {
        /**
         * 按用户名获取最大年龄
         * @param users
         * @return
         */
        public Map<String, Integer> getMaxAgeByUserName(List<User> users) {
            return users.stream()
                    // TODO 终止操作 ：根据name进行分组
                    .collect(groupingBy(User::getName))
                    // TODO 遍历每个key
                    .entrySet().stream()
                    // 转成map
                    .collect(toMap(
                            Map.Entry::getKey,
                            // 计算最大年龄
                            e -> e.getValue().stream()
                                    // 映射年龄
                                    .map(User::getAge)
                                    // 归约求值
                                    .reduce(0, Integer::max)
                    ));
        }
    }

    /**
     * TODO Ugly    Group By 使用 Max Collector Unwrapping 可选使用 Finisher
     */
    @Ugly
    class GroupByWithMaxCollectorUnwrappingOptionalWithFinisher {
        public Map<String, Integer> getMaxAgeByUserName(List<User> users) {
            return users.stream().collect(groupingBy(User::getName,
                    // collectingAndThen  and then
                    //  maxBy 求最大值
                    collectingAndThen(maxBy(comparing(User::getAge)),
                            user -> user.get().getAge())));
        }
    }

    /**
     * TODO GOOD 使用合并功能收集到map
     */
    @Good
    class CollectToMapWithMergeFunction {
        public Map<String, Integer> getMaxAgeByUserName(List<User> users) {
            return users.stream()
                    // 返回的Collector不是并发的。
                    // key value 合并规则
                    .collect(toMap(User::getName,
                            User::getAge,
                            Integer::max));
        }
    }

    /**
     * 将 Reduce Collector 应用为下游
     */
    @Good
    class ApplyReduceCollectorAsDownstream {
        public Map<String, Integer> getMaxAgeByUserName(List<User> users) {
            return users.stream()
                    // 分组
                    .collect(groupingBy(User::getName,
                            // TODO  映射  通过在累加之前对每个输入元素应用映射函数，将接受U类型元素的Collector调整为接受T类型元素。
                            mapping(User::getAge,
                            reducing(0, Integer::max))));
        }
    }
}
```

## 用于分组的外部集合

```JAVA
package com.xpinjection.java8.misused.stream.collectors;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Permission;
import com.xpinjection.java8.misused.User;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static java.util.stream.Collectors.*;

/**
 * @author link
 * TODO 用于分组的外部集合
 */
public class ExternalCollectionForGrouping {
    private final Set<User> users = new HashSet<>();

    /**
     * TODO Ugly 外部状态用于流操作
     */
    @Ugly
    class ExternalStateIsUsedForStreamOperations {
        /**
         * 查找编辑
         * @return
         */
        public Map<String, Set<User>> findEditors() {
            //editors 存储编辑
            Map<String, Set<User>> editors = new HashMap<>(16);
            users.forEach(u ->
                    // 遍历用户 获取所有角色组
                    u.getRoles().stream()
                            // 过滤所有角色中包含edit去授权的角色
                    .filter(r -> r.getPermissions().contains(Permission.EDIT))
                            // 遍历
                    .forEach(r -> {
                        //  使用 Multiset 并避免这种复杂的代码会更好吗
                        //is it better to use Multiset and avoid this complex code
                        // 封装用户和角色  editors.get(r.getName())这里外部set可能一开始为null 而add操作执行在put之后
                        Set<User> usersInRole = editors.get(r.getName());
                        if (usersInRole == null) {
                            usersInRole = new HashSet<>();
                            editors.put(r.getName(), usersInRole);
                        }
                        usersInRole.add(u);
                    })
            );
            return editors;
        }
    }

    /**
     * TODO 当后期需要状态时使用 元组
     */
    @Good
    class TuplesAreUsedWhenStateIsNeededOnLaterPhase {
        public Map<String, Set<User>> findEditors() {
            return users.stream()
                    .flatMap(u -> u.getRoles().stream()
                            //  获得角色组 过滤权限
                        .filter(r -> r.getPermissions().contains(Permission.EDIT))
                            // 映射成 角色 与 用户对象 （元组封装）
                        .map(r -> new Pair<>(r, u))
                    ).collect(groupingBy(p ->
                                    //  KEY为name
                                    p.getKey().getName(),
                            // value 为 用户set
                            mapping(Pair::getValue, toSet())));
        }
    }

    /**
     * any tuple implementation from 3rd party libraries
     * 来自 3rd 方库的任何类型元组实现
     * @param <K> key 的元对象
     * @param <V> value 的元对象
     */
    class Pair<K, V> {
        private final K key;
        private final V value;

        Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }

        K getKey() {
            return key;
        }

        V getValue() {
            return value;
        }
    }
}
```

## 统计计算

```JAVA
package com.xpinjection.java8.misused.stream.collectors;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.IntSummaryStatistics;
import java.util.List;
import java.util.stream.IntStream;

import static java.util.stream.Collectors.summarizingInt;

/**
 * @author link
 * TODO 统计计算
 */
public class StatisticsCalculation {
    /**
     * TODO Ugly 多次迭代值 每获取一个数据 一次求值计算
     */
    @Ugly
    class IterateThroughValuesSeveralTimes {
        /**
         * printNameStats 打印姓名统计数据
         *
         * @param users
         */
        public void printNameStats(List<User> users) {
            getNameLengthStream(users)
                    .max()
                    // 存在 打印最大值
                    .ifPresent(max -> System.out.println("MAX: " + max));
            getNameLengthStream(users)
                    .min()
                    // 存在 打印最小值
                    .ifPresent(min -> System.out.println("MIN: " + min));
        }

        /**
         * getNameLengthStream 获取名称长度流
         *
         * @param users
         * @return
         */
        private IntStream getNameLengthStream(List<User> users) {
            return users.stream()
                    .mapToInt(user -> user.getName().length());
        }
    }

    /**
     * TODO good 使用收集器在单次运行中计算统计数据   单次运行中计算统计数据
     */
    @Good
    class CalculateStatisticsInSingleRunWithCollector {
        public void registerUsers(List<User> users) {
            // 内部汇总统计
            IntSummaryStatistics statistics = users.stream()
                    // summarizing Int 总结 int
                    .collect(summarizingInt(user -> user.getName().length()));
            System.out.println("MAX: " + statistics.getMax());
            System.out.println("MIN: " + statistics.getMin());
            System.out.println("AVG: " + statistics.getAverage());
            System.out.println("Count: " + statistics.getCount());
            System.out.println("Sum: " + statistics.getSum());
        }
    }
}
```

## 流也许（可能）被转换成数组

```JAVA
package com.xpinjection.java8.misused.stream.collectors;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.List;
import java.util.stream.Collectors;

/**
 * @author link
 * 流可能（也许）被转换为数组
 */
public class StreamMayBeConvertedToArray {
    /**
     * TODO ugly 通过列表转换为数组
     */
    @Ugly
    class ConvertToArrayViaList {
        public String[] getUserNames(List<User> users) {
            //先转换成list
            List<String> names = users.stream()
                    //
                    .map(User::getName)
                    .collect(Collectors.toList());
            // 再转换成array
            return names.toArray(new String[names.size()]);
        }
    }

    /**
     * TODO good 直接转换为数组
     */
    @Good
    class ConvertToArrayDirectly {
        public String[] getUserNames(List<User> users) {
            return users.stream()
                    .map(User::getName)
                    // 直接转换成数组
                    .toArray(String[]::new);
        }
    }
}
```

## 真正的功能方法（函数）

```JAVA
package com.xpinjection.java8.misused.stream.collectors;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.List;

import static java.util.Comparator.comparingInt;

/**
 * @author link
 * TODO 真正的功能方法（函数）
 */
public class TrueFunctionalApproach {
    /**
     * TODO ugly BeforeJava8 在java8之前
     */
    @Ugly
    class BeforeJava8 {
        /**
         * 查找具有最多角色的用户
         * @param users
         * @return
         */
        public User findUsersWithMostRoles(List<User> users) {
            if (users.isEmpty()) {
                return null;
            }
            // mostPowerful 最具影响力 初始化第一个值
            User mostPowerful = users.iterator().next();
            for (User user : users) {
                // 比较角色数量 多则更改 mostPowerful
                if (user.getRoles().size() > mostPowerful.getRoles().size()) {
                    mostPowerful = user;
                }
            }
            return mostPowerful;
        }
    }

    /**
     * TODO ugly 朴素流方法
     *  Naive 幼稚
     */
    @Ugly
    class NaiveStreamsApproach {
        public User findUsersWithMostRoles(List<User> users) {
            return users.stream()
                    // 调用int比较 然后排序
                    .sorted(comparingInt(u -> u.getRoles().size()))
                    .findFirst()
                    .orElse(null);
        }
    }

    /**
     * TODO 减少(归约 还原)的流
     */
    @Ugly
    class StreamsWithReduction {
        public User findUsersWithMostRoles(List<User> users) {
            return users.stream()
                    // 归约
                    .reduce((u1, u2) ->
                            // 三元表达式判断
                            u1.getRoles().size() > u2.getRoles().size() ? u1 : u2)
                    .orElse(null);
        }
    }

    /**
     * TODO 带比较器的最大值
     */
    @Good
    class MaxWithComparator {
        public User findUsersWithMostRoles(List<User> users) {
            return users.stream()
                    // 比较后求最大值
                    .max(comparingInt(u -> u.getRoles().size()))
                    // 存在则返回get() 否则返回null
                    .orElse(null);
        }
    }
}
```

## 不正确 - 忘记终端操作

```JAVA
package com.xpinjection.java8.misused.stream.incorrect;

import com.xpinjection.java8.misused.Annotations.Bad;

import java.util.stream.IntStream;

/**
 * @author link
 * TODO  不正确的操作示例  忘记终端操作
 * 没有终止操作不会执行
 */
public class ForgotTerminalOperation {
    /**
     * TODO BAD 在现实中什么都不做 不会执行
     *
     */
    @Bad
    public void willDoNothingInReality() {
        IntStream.range(1, 5)
                // 返回由该流的元素组成的流，并在从结果流中消耗元素时对每个元素执行提供的操作。
                .peek(System.out::println)
                .peek(i -> {
                    if (i == 5) {
                        throw new RuntimeException("bang");
                    }
                    // 此方法的存在主要是为了支持调试，您希望在元素流过管道中的某个点时查看它们：
                }).peek(Integer::new);
    }
}
```

## 无限流

```JAVA
package com.xpinjection.java8.misused.stream.incorrect;

import com.xpinjection.java8.misused.Annotations.Bad;
import com.xpinjection.java8.misused.Annotations.Good;

import java.util.stream.IntStream;

/**
 * @author link
 * TODO 无限流
 */
public class InfiniteStreams {
    /**
     * infinite 无限流
     */
    @Bad
    public void infinite(){
        // iterate 迭代没有终止条件
        IntStream.iterate(0, i -> i + 1)
                .forEach(System.out::println);
    }

    /**
     * 通过limit限制流的  终止
     */
    @Good
    public void validOne(){
        IntStream.iterate(0, i -> i + 1)
                .limit(10)
                .forEach(System.out::println);
    }

    /**
     * TODO 仍然无限
     */
    @Bad
    public void stillInfinite(){
        IntStream.iterate(0, i -> ( i + 1 ) % 2)
                // 一直去重
                .distinct()
                .limit(10)
                .forEach(System.out::println);
    }

    /**
     * TODO 但是这个 如果很好
     */
    @Good
    public void butThisOneIfFine(){
        IntStream.iterate(0, i -> ( i + 1 ) % 2)
                .limit(10)
                .distinct()
                .forEach(System.out::println);
    }
}
```

## 使用流不止一次

```JAVA
package com.xpinjection.java8.misused.stream.incorrect;

import com.xpinjection.java8.misused.Annotations.Bad;

import java.util.Arrays;
import java.util.stream.IntStream;

/**
 * @author link
 * TODO 使用流 不止一次
 */
public class UseStreamMoreThanOnce {
    /**
     * 终端操作后关闭流
     */
    @Bad
    public void streamIsClosedAfterTerminalOperation() {
        int[] array = new int[]{1, 2};
        IntStream stream = Arrays.stream(array);
        // 终止操作流已关闭
        stream.forEach(System.out::println);
        array[0] = 2;
        stream.forEach(System.out::println);
        //IllegalStateException: stream has already been operated upon or closed
    }
}
```

## 创建选项

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Permission;
import com.xpinjection.java8.misused.Role;

import java.util.Arrays;
import java.util.Collections;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/**
 * @author link
 * 创建选项
 */
public class CreationOptions {
    /**
     * 从list中获取stream
     * 1.先转换成list
     * 2.在转换成strean
     * @return
     */
    @Ugly
    public Stream<Permission> getStreamFromList() {
        return Arrays.asList(Permission.ADD, Permission.DELETE).stream();
    }

    /**
     * 1.直接调用stream的转换
     * @return
     */
    @Good
    public Stream<Permission> getStreamFromElements() {
        return Stream.of(Permission.ADD, Permission.DELETE);
    }

    /**
     * 通过映射副本的方式生成stream
     * MappingCopies 复制后映射
     * @param n
     * @return
     */
    @Ugly
    public Stream<Role> generateStreamByMappingCopies(int n) {
        //nCopies copy n份
        return Collections.nCopies(n, "ignored").stream()
                // 每一份映射一个空角色
                .map(s -> new Role());
    }

    /**
     * IntStream 的方式生成stream
     * @param n
     * @return
     */
    @Ugly
    public Stream<Role> generateStreamFromRange(int n) {
        //IntStream.range(0, n) 创建一个0,n范围内的流
        return
                IntStream.range(0, n).mapToObj(i -> new Role());
    }

    /**
     * 使用 Supplier接口生成流 然后做截取
     * 推荐
     * @param n
     * @return
     */
    @Good
    public Stream<Role> generateStreamFromSupplierWithLimit(int n) {
        return Stream.generate(Role::new).limit(n);
    }

    /**
     * 通过array与范围的方式生成流
     * 1.先获取最小值
     * 2.在创建指定范围的流
     * 3.映射成对象
     * @param roles
     * @param max
     * @return
     */
    @Ugly
    public Stream<Role> generateStreamFromArrayWithRange(Role[] roles, int max) {
        int to = Integer.min(roles.length, max);
        return IntStream.range(0, to).mapToObj(i -> roles[i]);
    }

    /**
     * 通过stream流 直接截取
     * @param roles
     * @param max
     * @return
     */
    @Good
    public Stream<Role> generateStreamFromArrayWithLimit(Role[] roles, int max) {
        return Stream.of(roles).limit(max);
    }
}
```

## 不要忽视数据结构

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.*;

import static java.util.stream.Collectors.toList;

/**
 * @author link
 * 不要忽视数据结构
 */
public class DoNotNeglectDataStructures {
    /**
     * 不必要地使用嵌套流操作
     */
    @Ugly
    class UnnecessaryUseOfNestedStreamOperations {
        public List<Order> filterOrdersByStatuses(List<Order> orders, Set<Status> appropriateStatuses) {
            return orders.stream()
                    .filter(order ->
                            //过滤流中的任意一个匹配
                            appropriateStatuses.stream().anyMatch(order.getStatus()::equals))
                    .collect(toList());
        }
    }

    /**
     * UseOfDataStructure
     * 数据结构使用
     */
    @Good
    class UseOfDataStructure {
        public List<Order> filterOrdersByStatuses(List<Order> orders, Set<Status> appropriateStatuses) {
            return orders.stream()
                    // 使用数据结构的api
                    .filter(order -> appropriateStatuses.contains(order.getStatus()))
                    .collect(toList());
        }
    }

    /**
     * 状态存储在错误的数据结构中
     *
     */
    @Ugly
    class StateIsStoredInBadDataStructure {
        private final List<Order> orders = new ArrayList<>();

        public void placeOrder(Order order) {
            orders.add(order);
        }

        public List<Order> getOrdersInStatus(Status status) {
            return orders.stream()
                    // 每次需要进行对数据的过滤
                    // 可以考虑对数据预先进行分组
                    // EnumMap
                    .filter(order -> order.getStatus() == status)
                    .collect(toList());
        }
    }

    /**
     * 内部数据结构可以针对访问方法进行优化
     * EnumMap 枚举map存储数据
     */
    @Good
    class InternalDataStructureMayBeOptimizedForAccessMethods {
        //Use multimap instead from external collections like Guava
        private final Map<Status, List<Order>> orders = new EnumMap<>(Status.class);

        public void placeOrder(Order order) {
            // computeIfAbsent 计算如果不存在
            // 1.存在直接返回order.getStatus()
            // 2.不存在则添加到list中
            orders.computeIfAbsent(order.getStatus(), status -> new ArrayList<>()).add(order);
        }

        public List<Order> getOrdersInStatus(Status status) {
            // 获取对应状态的订单集合
            return orders.get(status);
        }
    }

    class Order {
        private Status status = Status.ACTIVE;

        Status getStatus() {
            return status;
        }

        void setStatus(Status status) {
            this.status = status;
        }
    }

    enum Status {
        ACTIVE, SUSPENDED, CLOSED
    }
}
```

## 命令式代码组合

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Permission;
import com.xpinjection.java8.misused.Role;
import com.xpinjection.java8.misused.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * @author link
 *
 * ImperativeCodeMix
 * 命令式代码组合
 */
public class ImperativeCodeMix {
    private static final String ADMIN_ROLE = "admin";

    private final List<User> users = new ArrayList<>();

    /**
     * 流操作和命令式代码的过于冗长的组合
     */
    @Ugly
    class TooVerboseMixOfStreamOperationsAndImperativeCode {
        /**
         * 判断是否为admin 橘色
         * @return
         */
        public boolean hasAdmin() {
            return users.stream()
                    .map(u -> {
                        if (u == null) {
                            throw new NullPointerException();
                        }
                        return u;
                    })
                    .flatMap(u -> u.getRoles().stream())
                    .map(Role::getName)
                    .anyMatch(name -> ADMIN_ROLE.equals(name));
        }
    }

    /**
     * 干净整洁的流运营(运行)链
     */
    @Good
    class NiceAndCleanStreamOperationsChain {
        /**
         * 判断是否为admin 橘色
         * @param permission
         * @return
         */
        public boolean hasAdmin(Permission permission) {
            return users.stream()
                    // Objects::requireNonNull 映射对象判空
                    // 必须为非空
                    .map(Objects::requireNonNull)
                    // 平铺对应的角色组
                    .flatMap(u -> u.getRoles().stream())
                    // 静态方法引用获取角色 名称
                    .map(Role::getName)
                    // 任意一个匹配是否为 admin角色
                    .anyMatch(ADMIN_ROLE::equals);
        }

    }
}
```

## 功能风格的匹配元素

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Permission;
import com.xpinjection.java8.misused.User;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author link
 * 功能风格的匹配元素
 */
public class MatchElementInFunctionalStyle {
    private final Set<User> users = new HashSet<>();

    /**
     * 对 For Each 和 External Boolean 使用老式迭代
     * AtomicBoolean 原子布尔值的运用
     */
    @Ugly
    class UseOldSchoolIterationsWithForEachAndExternalBoolean {
        public boolean checkPermission(Permission permission) {
            // 原子布尔值（避免并发情况下数据异常）
            AtomicBoolean found = new AtomicBoolean();
            users.forEach(
                    // 遍历用户组
                    u -> u.getRoles().forEach(
                            // 遍历每个用户所拥有的的角色
                            r -> {
                                // 判断用户是否包含挡圈授权
                                if (r.getPermissions().contains(permission)) {
                                    // 设置为true
                                    found.set(true);
                                }
                            }
                    )
            );
            // 返回授权信息
            return found.get();
        }
    }

    /**
     * 尝试使用带有流过滤器的功能样式
     */
    @Ugly
    class TryToUseFunctionalStyleWithStreamFilter {
        /**
         * 检查授权
         * @param permission
         * @return
         */
        public boolean checkPermission(Permission permission) {
            // 使用filter过滤用户
            return users.stream().filter(
                    u -> u.getRoles().stream()
                            // 过滤用户的角色组
                            .filter(
                                    // 过滤对应角色是否包含授权信息
                                    r -> r.getPermissions().contains(permission))
                            // 统计数量存在对应授权角色 返回当前用户
                            .count() > 0)
                    // 查找第一个对象  是否存在
                    // （存在：true，不存在：false）
                    .findFirst().isPresent();
        }
    }

    /**
     * 尝试使用流匹配
     */
    @Ugly
    class TryToUseStreamMatching {
        public boolean checkPermission(Permission permission) {
            return users.stream()
                    // 任何匹配
                    .anyMatch(u -> u.getRoles().stream()
                            // 角色中任何匹配
                            .anyMatch(r -> r.getPermissions().contains(permission)));
        }
    }

    /**
     * 对子集合使用平面映射
     */
    @Good
    class UseFlatMapForSubCollections {
        public boolean checkPermission(Permission permission) {
            return users.stream()
                    // 使用flatmap 平铺user的角色组转换成流（替代嵌套流）
                    .flatMap(u -> u.getRoles().stream())
                    // 角色任意匹配
                    .anyMatch(r -> r.getPermissions().contains(permission));
        }
    }

    /**
     * 将平面映射与子集合的方法引用一起使用
     */
    @Good
    class UseFlatMapWithMethodReferencesForSubCollections {
        public boolean checkPermission(Permission permission) {
            return users.stream()
                    // 映射角色组为stream
                    .map(User::getRoles)
                    // 平铺映射角色组为stream对象
                    .flatMap(Set::stream)
                    // 任意匹配授权信息
                    .anyMatch(r -> r.getPermissions().contains(permission));
        }
    }
}
```

## 嵌套的foreach

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import static java.util.stream.Collectors.toSet;

/**
 * @author 14688
 * 嵌套 foreach
 */
public class NestedForEach {
    /**
     * 为每个使用外部集合嵌套
     */
    @Ugly
    class NestedForEachWithExternalCollection {
        /**
         * 检索促销规则名称
         * @param transactions
         * @return
         */
        public Set<String> retrievePromoRuleNames(List<BusinessTransaction> transactions) {
            // 带有促销的规则名称组 ruleNamesWithPromo
            Set<String> ruleNamesWithPromo = new HashSet<>();
            transactions.forEach(transaction ->
                    // 获取商业对象的橘色组
                    transaction.getRules().stream()
                            // 过滤是否是促销规则
                    .filter(BusinessRule::isPromotion)
                            // 添加促销规则名 到规则组中
                    .forEach(rule -> ruleNamesWithPromo.add(rule.getRuleName())));
            // 返回 规则对象
            return ruleNamesWithPromo;
        }
    }

    /**
     * 流操作链
     */
    @Good
    class StreamOperationsChain {
        public Set<String> retrievePromoRuleNames(List<BusinessTransaction> transactions) {
            // 生成流
            return transactions.stream()
                    // 平铺映射角色组 为流对象
                    .flatMap(t -> t.getRules().stream())
                    // 过滤促销规则
                    .filter(BusinessRule::isPromotion)
                    // 映射对应规则名称
                    .map(BusinessRule::getRuleName)
                    // 终止操作  收集为set集合返回
                    .collect(toSet());
        }
    }

    /**
     * 商业交易
     */
    class BusinessTransaction {
        /**
         * 商业规则组
         * @return
         */
        List<BusinessRule> getRules() {
            return new ArrayList<>(); //stub 存根
        }
    }

    /**
     * 业务规则
     */
    class BusinessRule {
        String getRuleName() {
            return ""; //stub
        }

        boolean isPromotion() {
            return false; //stub
        }
    }
}
```

## 首选专用流

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.User;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author link
 * 首选 专业 流
 */
public class PreferSpecializedStreams {
    private final Set<User> users = new HashSet<>();

    /**
     * 一般流使用
     */
    @Ugly
    class GeneralStreamUsage {
        public int getTotalAge() {
            return users.stream()
                    // 映射用户年龄
                    .map(User::getAge)
                    // 使用提供的标识值和关联累积函数对此流的元素执行归约，并返回归约后的值。这相当于
                    // reduce sum求和 Integer 包装类频繁拆箱与装箱
                    // TODO 所谓的归约是将某个计算问题（英语：computational problem）转换为另一个问题的过程。
                    .reduce(0, Integer::sum);
        }
    }

    /**
     * 专业流使用
     */
    @Good
    class SpecializedStreamUsage {
        public int getTotalAge() {
            return users.stream()
                    // 直接转换成intStream流
                    .mapToInt(User::getAge)
                    // 调用intStream中特有的方法   省掉int类型数据的包装与拆箱
                    .sum();
        }
    }

    /**
     * TODO 丑陋的方式
     * TODO 使用平铺映射来统计所有集合中的元素
     */
    @Ugly
    class FlatMapToCountElementsInAllCollections {
        /**
         * 统计所有员工
         * @param departments
         * @return
         */
        public int countEmployees(Map<String, List<User>> departments) {
                        // departments.values().stream() map的所有value 转换成stream
            return (int) departments.values().stream()
                    // 平铺映射所有用户list
                    .flatMap(List::stream)
                    // 统计所有角色数
                    .count();
        }
    }

    /**
     * TODO good 的 使用方式
     * TODO 映射到 Int 以简化计算
     * 分析问题 ： 统计员工的数量（也就是计算员工的总数 只需要数量信息 也就没有必要遍历每个用户）
     */
    @Good
    class MapToIntToSimplifyCalculation {
        public long countEmployees(Map<String, List<User>> departments) {
            return departments.values().stream()
                    // list的长度 映射成int流
                    .mapToInt(List::size)
                    // 求和
                    .sum();
        }
    }
}
```

## 富领域模型

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;
import com.xpinjection.java8.misused.Role;
import com.xpinjection.java8.misused.User;

import java.util.ArrayList;
import java.util.List;

/**
 * @author link
 * 富 领域模型
 */
public class RichDomainModel {
    /**
     * TODO 丑陋的 糟糕的领域模型导致复杂的数据访问代码
     */
    @Ugly
    class PoorDomainModelCausesComplexDataAccessCode {
        private final List<User> users = new ArrayList<>();

        /**
         * 查找角色中的用户
         * @param roleName
         * @return
         */
        public User findUserInRole(String roleName) {
            // 遍历用户组
            for (User user : users) {
                // 遍历每个用户的角色组
                for (Role role : user.getRoles()) {
                    // 比较角色名称
                    if (roleName.equals(role.getName())) {
                        return user;
                    }
                }
            }
            // 查找不到结果 返回null
            return null;
        }
    }

    /**
     * TODO 丑陋的  流版本看起来并没有好多少
     */
    @Ugly
    class StreamVersionLooksNotMuchBetter {
        private final List<User> users = new ArrayList<>();

        public User findUserInRole(String roleName) {
            // 生成stream
            return users.stream().filter(user -> user.getRoles().stream()
                            .map(Role::getName)
                            // 过滤出name相等的user
                            .anyMatch(roleName::equals))
                    // 查找出任何 user Optional对象
                    .findAny()
                    // 否则返回 null
                    .orElse(null);
        }
    }

    /**
     * TODO GOOD 富领域模型可以简化访问代码（在领域模型中封装判断方法）
     */
    @Good
    class RichDomainModelCouldSimplifyAccessCode {
        private final List<BetterUser> users = new ArrayList<>();

        public User findUserInRole(String roleName) {
            return users.stream()
                    // 封装 角色对象的判断方法
                    .filter(user -> user.hasRole(roleName))
                    .findAny()
                    .orElse(null);
        }

        class BetterUser extends User {
            // 全参
            BetterUser(long id, String name, int age) {
                super(id, name, age);
            }

            boolean hasRole(String roleName) {
                // 用户角色组
                return getRoles().stream()
                        .map(Role::getName)
                        // 是否匹配角色名称的对象
                        .anyMatch(roleName::equals);
            }
        }
    }
}
```

## 具有新结构的相同样式代码

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.User;
import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.Collection;
import java.util.Objects;

import static java.util.Optional.ofNullable;

/**
 * @author link
 * 具有新结构的相同旧代码样式
 */
public class SameOldCodeStyleWithNewConstructs {
    /**
     * TODO 丑陋的  不一样的 旧循环 包含if
     */
    @Ugly
    class NoMoreThanSameOldLoopWithIf {
        public void registerUsers(Collection<User> users) {
            users.stream().forEach(user ->
                    // 判断非空时注册用户
                    // 返回一个描述指定值的Optional ，如果非 null ，否则返回一个空Optional 。
                    // 如果存在值，则使用该值调用指定的使用者，否则不执行任何操作。
                    ofNullable(user).ifPresent(u -> {
                        //register user
                    })
            );
        }
    }

    /**
     * TODO 新stream风格的 方法参考
     */
    @Good
    class NewStreamStyleWithMethodReference {
        public void registerUsers(Collection<User> users) {
            users.stream()
                    // 过滤非空
                    .filter(Objects::nonNull)
                    // 注册用户
                    .forEach(this::registerUser);
        }

        /**
         * 注册用户的方法
         * @param user
         */
        private void registerUser(User user){
            //register user
        }
    }
}
```

## SKIP+LIMIT在list中是浪费

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.User;

import java.util.List;

import static com.xpinjection.java8.misused.Annotations.Good;
import static com.xpinjection.java8.misused.Annotations.Ugly;

/**
 * @author link
 * 跳过 + 限制（截取） 在列表中 是浪费
 */
public class SkipAndLimitOnListIsWaste {
    /**
     * TODO 丑陋的 跳过一些元素，然后取一些进行处理
     */
    @Ugly
    class SkipSomeElementsAndThenTakeSomeForProcessing {
        public void registerUsers(List<User> users) {
            // 跳过5个 截取10个
            users.stream().skip(5).limit(10)
                    // 注册
                    .forEach(SkipAndLimitOnListIsWaste.this::registerUser);
        }
    }

    /**
     * TODO good 子列表不要浪费处理时间
     */
    @Good
    class SublistDoNotWasteProcessingTime {
        public void registerUsers(List<User> users) {
            // 返回此列表在指定fromIndex （包括）和toIndex （不包括）之间部分的视图。
            // 使用list的api  subList 直接截取对应的元素
            users.subList(5, 15)
                    .forEach(SkipAndLimitOnListIsWaste.this::registerUser);
        }
    }

    private void registerUser(User user) {
        //register user
    }
}
```

## 可以转换成无类型的流

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.List;

/**
 * @author link
 * 可以转换无类型的流
 */
public class UntypedStreamsCouldBeConverted {
    /**
     * TODO  Ugly  仅处理特殊类型的值
     */
    @Ugly
    class ProcessOnlyValuesOfSpecialType {
        // 统计double中的非数字个数
        public int countDoubleNaNs(List numbers) {
            int count = 0;
            for (Object e : numbers) {
                if (e instanceof Double) {
                    Double d = (Double) e;
                    //如果此Double值是非数字 (NaN)，则返回true ，否则返回false 。
                    if (d.isNaN()) {
                        count++;
                    }
                }
            }
            return count;
        }
    }

    /**
     * 可以更改 流的类型
     */
    @Good
    class TypeOfStreamCouldBeChanged {
        public int countDoubleNaNs(List numbers) {
            return (int) numbers.stream()
                    // double实例生成
                    .filter(Double.class::isInstance)
                    // 对象转换
                    .mapToDouble(Double.class::cast)
                    // 判断是否是非数字
                    .filter(Double::isNaN)
                    .count();
        }
    }
}
```

## 想在任何地方使用流

```JAVA
package com.xpinjection.java8.misused.stream;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.util.AbstractMap;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toMap;

/**
 * @author link
 * 想在 任何地方使用流
 */
public class WantToUseStreamsEverywhere {
    /**
     * TODO Ugly 使用 Stream 构建 map
     */
    @Ugly
    class UseStreamToBuildMap {
        /**
         * 获取 Jpa 属性
         * @return
         */
        public Map<String, Object> getJpaProperties() {
            return Stream.of(
                    //创建一个表示从指定键到指定值的映射的条目。
                    new AbstractMap.SimpleEntry<>("hibernate.show_sql", "true"),
                    new AbstractMap.SimpleEntry<>("hibernate.format_sql", "true")
            ).collect(collectingAndThen(
                    toMap(Map.Entry::getKey, Map.Entry::getValue),
                    // 收集成 不可更改的map
                    Collections::unmodifiableMap)
            );
        }
    }

    /**
     * TODO good  使用旧的朴实 map
     */
    @Good
    class UseOldPlainMap {
        public Map<String, Object> getJpaProperties() {
            Map<String, Object> properties = new HashMap<>(16);
            properties.put("hibernate.show_sql", "true");
            properties.put("hibernate.format_sql", "true");
            return Collections.unmodifiableMap(properties);
        }
    }
}
```

## TIME 新特性

```JAVA
package com.xpinjection.java8.misused.time;

import com.xpinjection.java8.misused.Annotations.Good;
import com.xpinjection.java8.misused.Annotations.Ugly;

import java.time.LocalDate;
import java.util.Calendar;
import java.util.Date;

import static java.time.temporal.ChronoUnit.DAYS;

/**
 * @author link
 * 时间api的无知
 * 使用LocalDate 新特性
 */
public class TimeApiIgnorance {
    /**
     * 在 Java 8以前 样式中添加 Day
     */
    @Ugly
    class AddDayInPreJava8Style {
        public Date tomorrow() {
            Calendar now = Calendar.getInstance();
            now.add(Calendar.DAY_OF_MONTH, 1);
            return now.getTime();
        }
    }

    /**
     * 添加一天效率低下
     */
    @Ugly
    class AddDayInefficient {
        public LocalDate tomorrow() {
            // 指定常量类添加
            return LocalDate.now().plus(1, DAYS);
        }
    }

    /**
     * 以 Java 8 风格添加一天
     */
    @Good
    class AddDayInJava8Style {
        public LocalDate tomorrow() {
            // 调用对应包装方法添加
            return LocalDate.now().plusDays(1);
        }
    }
}
```











